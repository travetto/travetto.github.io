<div class="documentation"><h1 id="compiler">Compiler</h1>
<p>The framework, while using <a class="external-link" href="http://typescriptlang.org" target="_blank" null><code>typescript</code></a>, has need of some extended functionality. The additional functionality is</p>
<ul>
<li>Supports on-the-fly compilation, nothing needs to be compiled ahead of time</li>
<li>Enhanced AST transformations, and transformer registration<ul>
<li>All AST transformations are single-file based, and runs without access to the <code>TypeChecker</code></li>
</ul>
</li>
<li>Intelligent caching of source files to minimize recompilation</li>
<li>Support for watching sources files:<ul>
<li>Detecting changes to files</li>
<li>Detecting changes to specific classes</li>
<li>Detecting changes to specific methods within classes</li>
</ul>
</li>
<li>Allows for hot-reloading of classes during development<ul>
<li>Utilizes <code>es2015</code> <code class="inline language-typescript">Proxy</code>s to allow for swapping out implementation at runtime</li>
</ul>
</li>
</ul>
<p>Additionally, there is support for common AST transformation patterns to facilitate all the transformers used throughout the framework. Functionality includes:</p>
<ul>
<li><code class="inline language-typescript">getDecoratorIdent(d: ts.Decorator): ts.Identifier</code><br>Gets the name of the decorator function</li>
<li><code class="inline language-typescript">findAnyDecorator(node: ts.Node, patterns: {{ '{' }} [key: string]: Set&lt;string&gt; {{ '}' }}, state: State): ts.Decorator | undefined</code><br>Attempts to find any matching decorators as defined in patterns</li>
<li><code class="inline language-typescript">addImport(file: ts.SourceFile, imports: Import[])</code><br>Will add an import to the existing source file</li>
<li><code class="inline language-typescript">fromLiteral(val: any)</code><br>Converts a literal value to the corresponding AST nodes</li>
<li><code class="inline language-typescript">extendObjectLiteral(addTo: object, lit?: ts.ObjectLiteralExpression)</code><br>Extends an AST Node via a literal value, generally used to emulate <code class="inline language-typescript">Object.assign</code> in the AST</li>
<li><code class="inline language-typescript">getPrimaryArgument&lt;T = ts.Node&gt;(node: ts.CallExpression | ts.Decorator | undefined): T | undefined</code><br>Retrieves the first argument of CallExpression or Decorator</li>
<li><code class="inline language-typescript">getObjectValue(node: ts.ObjectLiteralExpression | undefined, key: string)</code><br>Extracts the literal value from an AST node if possible</li>
<li><code class="inline language-typescript">importingVisitor</code><br>Provides a transformer visitor that collects imports, and adds them to the source file as needed</li>
<li><code class="inline language-typescript">importIfExternal&lt;T extends State&gt;(typeNode: ts.TypeNode, state: State)</code><br>Will import a reference if the type is not defined within the file</li>
<li><code class="inline language-typescript">buildImportAliasMap(pathToType)</code><br>Will generate an import lookup to be used for simple type resolution</li>
</ul>
<p>Transformations are defined by <code class="path">support/transformation.&lt;name&gt;.ts</code> as the filename. The schema for a transformer is </p>
<pre><code class="language-typescript">  <span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CustomerTransformer</span> <span class="token punctuation">{{ '{' }}</span>
    priority<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token comment">// Lower is higher priority</span>
    phase<span class="token punctuation">:</span> <span class="token string">'before'</span><span class="token operator">|</span><span class="token string">'after'</span><span class="token punctuation">,</span> <span class="token comment">// The phase as defined by Typescript's AST processing</span>
    transformer<span class="token punctuation">:</span> <span class="token punctuation">(</span>context<span class="token punctuation">:</span> ts<span class="token punctuation">.</span>TransformationContext<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{{ '{' }}</span>
       <span class="token keyword">return</span> <span class="token punctuation">(</span>file<span class="token punctuation">:</span> ts<span class="token punctuation">.</span>SourceFile<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{{ '{' }}</span>
         <span class="token operator">...</span> modify source file <span class="token operator">...</span>
         <span class="token keyword">return</span> file<span class="token punctuation">;</span>
       <span class="token punctuation">{{ '}' }}</span>
    <span class="token punctuation">{{ '}' }}</span>
  <span class="token punctuation">{{ '}' }}</span></code></pre></div>
